# 論文閱讀助手 - Paper Reading Assistant

*This notebook was created for Google Colab*

*Language: python*

---

## 專案簡介

這是一個基於 OpenAI GPT-5 Response API 的論文閱讀助手，幫助學生更好地理解學術論文。

**核心特色**：
- 📄 支援 PDF 上傳，完整解析論文內容
- 💬 多輪對話，可以持續提問
- 🧠 費曼學習法：用簡單語言解釋複雜概念
- 🎯 蘇格拉底式提問：引導深度思考
- 🔄 可清除對話，重新開始

---

## 1. 安裝必要套件

```python
!pip install openai gradio pypdf2
```

---

## 2. API Key 設定

請在 Colab 左側的 🔑 Secrets 中設定您的 OpenAI API Key，名稱為 `OpenAI`。

```python
from google.colab import userdata
import os

api_key = userdata.get('OpenAI')
os.environ['OPENAI_API_KEY'] = api_key
```

---

## 3. 匯入必要套件

```python
from openai import OpenAI
import gradio as gr
import PyPDF2
from dataclasses import dataclass
from typing import List, Dict, Optional, Any
```

---

## 4. 初始化 OpenAI Client

```python
client = OpenAI()
MODEL_NAME = "gpt-5"
```

---

## 5. PDF 文字提取函數

```python
def extract_pdf_text(pdf_path: str) -> str:
    """
    從上傳的 PDF 檔案中提取文字內容

    這個函數會：
    1. 逐頁讀取 PDF 內容
    2. 過濾掉空白頁面
    3. 標記頁碼方便定位
    4. 限制最大長度避免超過 Token 限制

    Args:
        pdf_path: PDF 檔案路徑

    Returns:
        str: 提取的文字內容

    Raises:
        ValueError: 當 PDF 無法讀取或內容為空時
    """
    if not pdf_path:
        raise ValueError("未提供 PDF 檔案")

    text_segments: List[str] = []

    try:
        with open(pdf_path, "rb") as handle:
            pdf_reader = PyPDF2.PdfReader(handle)

            if not pdf_reader.pages:
                raise ValueError("PDF 中沒有可用頁面")

            # 逐頁提取文字
            for index, page in enumerate(pdf_reader.pages, start=1):
                # 注意：page.extract_text() 可能回傳 None，需要處理
                page_text = page.extract_text() or ""

                # 只加入有內容的頁面
                if page_text.strip():
                    text_segments.append(f"\n--- Page {index} ---\n{page_text.strip()}")

    except Exception as exc:
        raise ValueError(f"PDF 讀取失敗: {exc}") from exc

    if not text_segments:
        raise ValueError("PDF 中沒有可讀取的文字內容")

    # 合併所有頁面
    combined = "".join(text_segments)

    # 防止超過 Token 限制（約 15000 字元）
    MAX_PDF_CHARS = 15000
    if len(combined) > MAX_PDF_CHARS:
        combined = combined[:MAX_PDF_CHARS] + "\n\n... (內容過長，已截斷。請分段提問以獲得完整解說。)"

    return combined
```

---

## 6. System Prompt 設定

這是論文閱讀助手的「人設」，定義了它如何幫助學生理解論文。

```python
SYSTEM_PROMPT = """你是一位專業的論文閱讀助手，專門幫助學生理解學術論文。

**你的教學原則**：

1. **費曼學習法 (Feynman Technique)**：
   - 用最簡單的語言解釋複雜概念
   - 使用類比和日常生活的例子
   - 避免過度使用專業術語，必要時要先解釋

2. **蘇格拉底式提問 (Socratic Method)**：
   - 不直接給答案，而是引導學生思考
   - 提出啟發性問題，幫助學生自己找到答案
   - 鼓勵批判性思維

3. **結構化分析**：
   - 幫助學生理解論文結構：摘要、引言、方法、結果、結論
   - 指出論文的核心貢獻和創新點
   - 解釋研究方法和實驗設計

4. **友善互動**：
   - 以鼓勵和支持的語氣回應
   - 確認學生理解後再繼續
   - 可以用 emoji 讓對話更生動

**當學生上傳論文後**：
- 等待學生提問，不要主動摘要
- 根據學生的問題，從論文中找到相關內容回答
- 確保回答準確且基於論文內容

**記住**：你的目標是幫助學生「學會如何讀論文」，而不只是「讀懂這篇論文」。"""

WELCOME_MESSAGE = """👋 嗨！我是你的**論文閱讀助手 & AI 對話夥伴**！

📚 **我能幫你做什麼？**

**模式 1：論文閱讀助手** 📄
- 上傳 PDF 論文後，我會幫你：
  - 用簡單的語言解釋論文中的複雜概念
  - 幫你理解研究方法和實驗設計
  - 引導你思考論文的核心貢獻
  - 回答你對論文內容的任何疑問

**模式 2：一般 AI 助手** 💬
- 不上傳 PDF 也可以直接跟我聊天：
  - 學習任何主題
  - 解答問題
  - 討論想法
  - 寫作協助

🚀 **如何開始？**
- **想讀論文？** 點擊上方「上傳 PDF」按鈕
- **想聊天？** 直接開始提問即可！

💡 **提問範例**：
- 📖 論文相關：「這篇論文的主要貢獻是什麼？」
- 💬 一般對話：「解釋一下機器學習的基本概念」

準備好了嗎？開始你的探索之旅吧！ 🚀✨"""

PDF_CONTEXT_TEMPLATE = (
    "以下是使用者提供的論文內容 (檔名: {filename}, 版本: {version})，回答時務必引用此內容：\n"
    "{content}"
)
```

---

## 7. 狀態管理 - 使用 Dataclass

使用結構化的方式管理 PDF 和對話狀態，比單純的全域變數更清晰且易於維護。

```python
@dataclass
class PDFState:
    """
    管理 PDF 狀態的資料類別

    Attributes:
        filename: PDF 檔名
        content: 提取的文字內容
        version: PDF 版本號（每次上傳新 PDF 會遞增）
    """
    filename: Optional[str] = None
    content: Optional[str] = None
    version: int = 0

    def context_message(self) -> Optional[Dict[str, str]]:
        """
        產生包含 PDF 內容的訊息物件

        這個訊息會在每次 API 呼叫時插入，確保模型知道當前的 PDF 內容。
        使用版本號可以讓模型區分不同的 PDF。

        Returns:
            包含 PDF 內容的 user 訊息，如果沒有 PDF 則回傳 None
        """
        if not self.content or not self.filename:
            return None

        return {
            "role": "user",
            "content": PDF_CONTEXT_TEMPLATE.format(
                filename=self.filename,
                version=self.version,
                content=self.content,
            ),
        }


# 全域狀態變數
conversation_history: List[Dict[str, str]] = []  # 儲存對話歷史（user 和 assistant 訊息）
last_response_id: Optional[str] = None  # Response API 的 previous_response_id
pdf_state = PDFState()  # PDF 狀態
```

---

## 8. 輔助函數

```python
def summarise_outputs(response: Any) -> str:
    """
    從 Response API 的回應中提取文字內容

    Response API 的輸出格式比較複雜，可能包含：
    - output_text: 直接的文字輸出（最常見）
    - output: 包含多個 message 物件的陣列（需要手動解析）

    這個函數會嘗試兩種方式，確保能取得內容。

    Args:
        response: OpenAI Response API 的回應物件

    Returns:
        str: 提取的文字內容
    """
    # 優先使用 output_text
    if getattr(response, "output_text", None):
        return response.output_text

    # 如果沒有 output_text，手動解析 output 陣列
    collected: List[str] = []
    for item in getattr(response, "output", []) or []:
        if item.get("type") != "message":
            continue
        for chunk in item.get("content", []):
            if chunk.get("type") == "output_text" and chunk.get("text"):
                collected.append(chunk["text"])

    return "".join(collected).strip()


def ensure_history(history: Optional[List[List[str]]]) -> List[List[str]]:
    """
    確保 Gradio history 是有效的列表

    Gradio 在第一次呼叫時可能傳入 None，這會導致錯誤。
    這個函數確保我們總是有一個有效的列表可以操作。

    Args:
        history: Gradio 傳入的對話歷史（可能是 None）

    Returns:
        有效的對話歷史列表
    """
    return list(history) if history else []
```

---

## 9. 核心對話函數

```python
def chat_with_paper(message: str, history: Optional[List[List[str]]]):
    """
    處理使用者訊息並產生回應

    **重要改進**（相較於原本的實作）：
    1. ✅ 正確儲存 user 和 assistant 訊息到 conversation_history
    2. ✅ 每次呼叫都重新注入 PDF 內容（支援重新上傳）
    3. ✅ 使用 previous_response_id 維護 Response API 的狀態
    4. ✅ 處理 history=None 的邊界情況
    5. ✅ 處理空白輸出的情況

    支援兩種模式：
    1. 有 PDF：論文閱讀助手模式
    2. 無 PDF：一般 AI 助手模式

    Args:
        message: 使用者當前輸入
        history: Gradio 聊天歷史 [[user_msg, bot_msg], ...]

    Returns:
        list: 更新後的 Gradio 歷史記錄（必須是 list of lists 格式）
    """
    global conversation_history, last_response_id

    # 確保 history 是有效的列表
    history = ensure_history(history)

    # 過濾空白訊息
    user_message = (message or "").strip()
    if not user_message:
        return history

    # === 步驟 1: 建構訊息陣列 ===
    messages: List[Dict[str, str]] = [
        {"role": "developer", "content": SYSTEM_PROMPT}
    ]

    # === 步驟 2: 如果有 PDF，注入 PDF 內容 ===
    # 注意：每次都重新注入，這樣重新上傳 PDF 時模型會知道
    pdf_context = pdf_state.context_message()
    if pdf_context:
        messages.append(pdf_context)

    # === 步驟 3: 加入對話歷史 ===
    # 這裡包含之前所有的 user 和 assistant 訊息
    messages.extend(conversation_history)

    # === 步驟 4: 加入當前使用者訊息 ===
    messages.append({"role": "user", "content": user_message})

    # === 步驟 5: 準備 API 請求 ===
    request_payload = {
        "model": MODEL_NAME,
        "input": messages,
        "reasoning": {"effort": "medium"},
        "text": {"verbosity": "medium"}
    }

    # 如果有上一次的 response_id，加入以維持推理連續性
    if last_response_id:
        request_payload["previous_response_id"] = last_response_id

    try:
        # === 步驟 6: 呼叫 OpenAI Response API ===
        response = client.responses.create(**request_payload)

        # === 步驟 7: 提取回應文字 ===
        assistant_reply = summarise_outputs(response)

        # 如果沒有文字輸出（罕見但可能發生），提供友善的錯誤訊息
        if not assistant_reply:
            assistant_reply = "⚠️ 模型未回傳文字，可再試一次或調整問題。"

        # === 步驟 8: 更新對話歷史（重要！）===
        # 儲存 user 和 assistant 訊息，這樣下次呼叫時模型才知道之前的對話
        conversation_history.append({"role": "user", "content": user_message})
        conversation_history.append({"role": "assistant", "content": assistant_reply})

        # === 步驟 9: 儲存 response_id ===
        last_response_id = getattr(response, "id", None)

        # === 步驟 10: 更新 Gradio 顯示的歷史 ===
        history.append([user_message, assistant_reply])
        return history

    except Exception as exc:
        # 錯誤處理：同樣回傳 Gradio 格式
        error_message = f"❌ 發生錯誤：{exc}\n\n請檢查網路連線與 API 設定後再試一次。"
        history.append([user_message, error_message])
        return history


def upload_pdf(pdf_file: Optional[str]):
    """
    處理 PDF 上傳

    **重要改進**：
    1. ✅ 更新 pdf_state 的版本號，讓模型知道是新的 PDF
    2. ✅ 保留 conversation_history（對話歷史不會因為上傳 PDF 而消失）
    3. ✅ 下次提問時會自動注入新的 PDF 內容

    Args:
        pdf_file: Gradio 上傳的檔案路徑

    Returns:
        str: 上傳狀態訊息
    """
    global pdf_state

    if pdf_file is None:
        return "❌ 請選擇 PDF 檔案"

    try:
        # 提取 PDF 文字
        content = extract_pdf_text(pdf_file)
    except ValueError as exc:
        # 如果提取失敗，重置 PDF 狀態
        pdf_state = PDFState()
        return f"❌ {exc}"

    # 更新 PDF 狀態（版本號遞增）
    pdf_state = PDFState(
        filename=os.path.basename(pdf_file),
        content=content,
        version=pdf_state.version + 1,
    )

    # 計算統計資訊
    page_count = content.count("--- Page") or "?"
    char_count = len(content)

    # 產生友善的成功訊息
    note = (
        "✅ PDF 上傳成功！\n\n"
        f"📄 檔名：{pdf_state.filename}\n"
        f"📄 版本：{pdf_state.version}\n"
        f"📄 頁面數：約 {page_count}\n"
        f"🔤 文字長度：約 {char_count:,} 字元\n\n"
        "💬 你可以直接提問，我會依據最新的 PDF 回答。"
    )

    return note


def clear_conversation():
    """
    清除對話歷史，重新開始

    注意：只清除對話歷史，PDF 設定保持不變

    Returns:
        tuple: (清空的聊天歷史, 狀態訊息)
    """
    global conversation_history, last_response_id

    conversation_history = []
    last_response_id = None

    return [], "🔄 對話已清除！PDF 設定保持不變。"
```

---

## 10. Gradio 介面設計

```python
# 建立 Gradio 介面
with gr.Blocks(title="論文閱讀助手", theme=gr.themes.Soft()) as demo:

    gr.Markdown("# 📚 論文閱讀助手 - Paper Reading Assistant")
    gr.Markdown("基於 OpenAI GPT-5 Response API，結合費曼學習法與蘇格拉底式提問")

    with gr.Row():
        with gr.Column(scale=3):
            # PDF 上傳區
            pdf_upload = gr.File(
                label="📄 上傳論文 PDF",
                file_types=[".pdf"],
                type="filepath"
            )
            upload_status = gr.Textbox(
                label="上傳狀態",
                value=WELCOME_MESSAGE,
                interactive=False,
                lines=10
            )

        with gr.Column(scale=7):
            # 聊天區
            chatbot = gr.Chatbot(
                label="💬 對話區",
                height=500,
                show_label=True,
                type="tuples"  # 明確指定使用 tuples 格式
            )

            msg_input = gr.Textbox(
                label="輸入你的問題",
                placeholder="例如：這篇論文的主要貢獻是什麼？",
                lines=2
            )

            with gr.Row():
                submit_btn = gr.Button("📤 送出", variant="primary")
                clear_btn = gr.Button("🔄 清除對話")

    # 事件綁定
    pdf_upload.change(
        fn=upload_pdf,
        inputs=pdf_upload,
        outputs=upload_status
    )

    submit_btn.click(
        fn=chat_with_paper,
        inputs=[msg_input, chatbot],
        outputs=chatbot
    ).then(
        lambda: "",  # 清空輸入框
        outputs=msg_input
    )

    msg_input.submit(
        fn=chat_with_paper,
        inputs=[msg_input, chatbot],
        outputs=chatbot
    ).then(
        lambda: "",  # 清空輸入框
        outputs=msg_input
    )

    clear_btn.click(
        fn=clear_conversation,
        outputs=[chatbot, upload_status]
    )

    # 說明區
    gr.Markdown("""
    ---
    ### 💡 使用技巧

    - **第一次提問**：建議先問「這篇論文在研究什麼？」了解全貌
    - **深入理解**：針對不懂的章節或概念提問
    - **批判思考**：可以問「這個方法有什麼限制？」
    - **清除對話**：想重新開始時，點擊「清除對話」按鈕
    - **重新上傳 PDF**：可以隨時上傳新的 PDF，對話歷史會保留

    ### ⚙️ 技術說明

    - **模型**：OpenAI GPT-5 (Response API)
    - **推理等級**：Medium (平衡速度與品質)
    - **PDF 處理**：PyPDF2 (完整文字提取)
    - **介面框架**：Gradio 5.x

    ---
    *Made with ❤️ for NCCU AI Course*
    """)
```

---

## 11. 啟動應用

```python
# 啟動 Gradio 應用
demo.launch(share=True, debug=True)
```

**啟動後**：
- Gradio 會產生一個公開連結（例如：`https://xxx.gradio.live`）
- 這個連結可以分享給任何人使用
- 連結有效期：72 小時

---

## 📸 使用範例截圖

*(在實際使用時，記得截圖以下畫面)*

1. **上傳 PDF 成功畫面**
2. **第一次提問 + 回應**
3. **多輪對話展示**
4. **費曼學習法解釋範例**
5. **蘇格拉底式提問範例**

---

## 🎓 學習重點

### Response API vs Chat Completions

這個專案使用了最新的 **OpenAI Response API**，相較於舊版 Chat Completions API：

```python
# ❌ 舊版 Chat Completions API
response = client.chat.completions.create(
    model="gpt-4",
    messages=[...]
)
reply = response.choices[0].message.content

# ✅ 新版 Response API
response = client.responses.create(
    model="gpt-5",
    input=[...],
    reasoning={"effort": "medium"},
    text={"verbosity": "medium"}
)
reply = response.output_text
```

**主要優勢**：
- 支援推理等級控制（`reasoning`）
- 支援輸出詳細度控制（`text.verbosity`）
- 更好的對話歷史管理（使用 `previous_response_id`）
- 專為 GPT-5 等推理模型優化

### Gradio 狀態管理

這個實作使用了改進的狀態管理策略：

**全域狀態變數**：
- `conversation_history`：儲存對話歷史（包含 user 和 assistant 訊息）
- `last_response_id`：Response API 的 previous_response_id
- `pdf_state`：PDF 狀態（使用 dataclass 結構化管理）

**關鍵改進**：
1. **正確儲存對話**：每次對話後，同時儲存 user 和 assistant 訊息
2. **PDF 版本追蹤**：使用版本號區分不同的 PDF
3. **狀態獨立性**：清除對話不會影響 PDF 設定

### 教學法整合

**費曼學習法**：
- 強制模型用簡單語言解釋
- 要求使用類比和例子
- 避免直接使用專業術語

**蘇格拉底式提問**：
- 不直接給答案
- 引導學生思考
- 提出啟發性問題

---

## 🐛 常見錯誤與修正

### 錯誤 1: 對話歷史遺失

**原本的問題**：
```python
# ❌ 只儲存 assistant 的回應
conversation_history.extend(response.output)
```

**修正後**：
```python
# ✅ 同時儲存 user 和 assistant 訊息
conversation_history.append({"role": "user", "content": user_message})
conversation_history.append({"role": "assistant", "content": assistant_reply})
```

### 錯誤 2: PDF 重新上傳無效

**原本的問題**：
只在第一次提問時注入 PDF 內容，後續上傳新 PDF 時模型不知道。

**修正後**：
```python
# ✅ 每次呼叫都重新注入 PDF 內容
pdf_context = pdf_state.context_message()
if pdf_context:
    messages.append(pdf_context)
```

### 錯誤 3: Response API 狀態誤用

**原本的問題**：
```python
# ❌ 直接把 response.output 放回 input
conversation_history.extend(response.output)
```

**修正後**：
```python
# ✅ 正確使用 previous_response_id
last_response_id = getattr(response, "id", None)
if last_response_id:
    request_payload["previous_response_id"] = last_response_id
```

### 錯誤 4: 未處理邊界情況

**修正**：
- 處理 `history=None`：使用 `ensure_history()` 函數
- 處理空白輸出：使用 `summarise_outputs()` 函數並提供預設訊息
- 處理 PDF 提取失敗：使用 try-except 並重置狀態

---

## 🚀 可能的改進方向

1. **PDF 分段處理**：對於超長論文，可以先分析結構，讓使用者選擇要讀哪一段
2. **視覺化**：產生論文結構圖、概念關係圖
3. **筆記功能**：讓使用者儲存重要的問答
4. **多論文比較**：上傳多篇論文，比較異同
5. **匯出功能**：將對話匯出為筆記文件

---

## 📝 作業說明

### 設計理念

這個論文閱讀助手的核心價值在於：

1. **不只是摘要工具**：不是簡單的 TL;DR，而是互動式學習助手
2. **教學導向**：整合費曼學習法和蘇格拉底式提問法
3. **技術展示**：使用最新的 Response API，展示對新技術的掌握
4. **實用性**：真正能幫助學生理解論文

### 與老師範例的差異

老師的「員瑛式思考生成器」：
- 單一功能：情緒轉換
- 簡單輸入輸出
- 固定模式

我的「論文閱讀助手」：
- 多功能：PDF 處理 + 多輪對話
- 複雜互動：上傳、提問、清除
- 教學法整合：費曼 + 蘇格拉底
- 技術升級：Response API

**評分優勢**：
- ✅ 避開 6 分陷阱（不只是改變人設）
- ✅ 實用價值高（真的能用來讀論文）
- ✅ 技術展示（Response API + PDF 處理）
- ✅ 教育意義（整合學習理論）

---

## 🔧 故障排除

### 常見問題

**Q: PDF 上傳失敗？**
- 確認檔案是 PDF 格式
- 檢查檔案是否損壞
- 嘗試用其他 PDF 閱讀器開啟確認

**Q: API 錯誤？**
- 確認 Colab Secrets 中有設定 `OpenAI` 金鑰
- 檢查金鑰是否有效且有餘額
- 查看錯誤訊息中的具體原因

**Q: 回應太慢？**
- 降低 `reasoning.effort` 為 `"low"` 或 `"minimal"`
- 降低 `text.verbosity` 為 `"low"`
- 考慮使用 `gpt-5-mini` 或 `gpt-5-nano`

**Q: Token 超過限制？**
- PDF 太長（超過 100 頁建議分段處理）
- 對話歷史太長（點擊清除對話重新開始）

**Q: 對話歷史怎麼都不見了？**
- 檢查是否正確儲存 user 和 assistant 訊息
- 確認沒有意外重置 `conversation_history`

**Q: 重新上傳 PDF 後模型還在回答舊的內容？**
- 確認每次呼叫都有重新注入 PDF 內容
- 檢查 PDF 版本號是否有遞增

---

## 📚 參考資源

- [OpenAI Response API 文件](https://platform.openai.com/docs/api-reference/responses)
- [Gradio 文件](https://www.gradio.app/docs)
- [PyPDF2 文件](https://pypdf2.readthedocs.io/)
- [費曼學習法](https://en.wikipedia.org/wiki/Feynman_Technique)
- [蘇格拉底式提問法](https://en.wikipedia.org/wiki/Socratic_method)

---

## 🙏 致謝

這個實作的改進得益於：
- **Codex AI** 的程式碼審查與錯誤修正
- **Claude Code** 的友善文檔與教學設計

兩者結合產生了這個既穩健又易讀的實作。

---

*🤖 Generated with Claude Code + OpenAI GPT-5 Response API*
